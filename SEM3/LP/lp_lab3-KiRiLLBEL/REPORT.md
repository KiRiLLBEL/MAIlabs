#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Белоносов К.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Язык Пролог удачно подходит для решения задач связанных с нахождением путей в графах, так как алгоритм глубокого поиска является для него родным, что позволяет очень естественно его описать. К тому же мы можем задавать легко задавать с помощью структурных термов как связи между узлами графа, состояния в графе состояний и вес перехода между состояниями.

Средства языка пролог позволяют рассматривать поиск в пространстве состояний как поиск в графе, а переход между состояниями можно описать с помощью предикатов, что позволяет нам генерировать наш граф состояний.
Пространство состояний и поиск в нем применяется в серии задач искусственного интеллекта.

## Задание

Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3
белых шара. Передвинуть черные шары на место белых, а белые - на
место черных. Шар можно передвинуть в соседнюю с ним пустую
лунку, либо в пустую лунку, находящуюся непосредственно за
ближайшим шаром.

## Принцип решения

> Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. Какие алгоритмы поиска вы использовали?

Основой моего задания является:

1. Выбор способа хранения состояния системы
2. Описание правил перехода между состояниями

Так как длина нашей последовательности объектов является постоянной, то мы с легкостью можем обратиться к спискам. Будем хранить последовательность наших мячей в виде списка и поддерживать инвариант массива на нашем списке. Из условия мы понимаем, что существует 4 основных варианта перехода между нашими состояниями, а именно:

1. `[0, b]` -> `[b, 0]`
2. `[w, 0]` -> `[0, w]`
3. `[w, b, 0]` -> `[0, b, w]`
4. `[0, w, b]` -> `[b, w, 0]`

Где: `w` - белый шар, `b` - черный шар, `0` - пустая лунка.
Опишем переходы с помощью предиката `move`:
```prolog
move(Now, Next) :-
    append(H, [0, b|T], Now),
    append(H, [b, 0|T], Next).
move(Now, Next) :-
    append(H, [w, 0|T], Now),
    append(H, [0, w|T], Next).
move(Now, Next) :-
    append(H, [w, b, 0|T], Now),
    append(H, [0, b, w|T], Next).
move(Now, Next) :-
    append(H, [0, w, b|T], Now),
    append(H, [b, w, 0|T], Next).
```

Описав схему хранения состояний и правила перехода между ними, мы можем свести задачу к поиску пути в графе. Реализуем 4 основных алгоритма, а именно `DFS`, `BFS`, поиск с итеративным погружением (`IDDFS`) и эвристический алгоритм `A*`.

Прежде всего для упрощения решения опишем предикат `prolong`, отвечающий за переход в другое состояние и проверку на его посещенность.

Обычный предикат:

```prolog
prolong([Now|T], [Next, Now|T]) :-
    move(Now, Next),
    not(member(Next, [Now|T])).
```

Для эврестического поиска:

```prolog
prolong_a(C:[Now|T], C1:[Next, Now|T]) :-
    move(Now, Next),
    not(member(Next,[Now|T])),
    C1 is C + 1.
```

`DFS` является самым простым и чаще всего быстрым алгоритмом, но он не позволяет находить сразу же кратчайший путь в графе.

```prolog
dfs(Start, End) :- 
    get_time(Start_time), 
    dfs_other([Start], End, Length), !,
    get_time(Finish_time), 
    Time is Finish_time - Start_time,
    write("Statitics: "), write("Time: "), write(Time), write("\tLength: "), write(Length), nl.
dfs_other([End|T], End, Length) :- 
    print_list([End|T], C),
    Length=C.
dfs_other(Now, End, Length) :-
    prolong(Now, Next),
    dfs_other(Next, End, Length).
```

Для реализации `BFS` нам необходимо поддерживать инвариант очереди на нашем списке состояний, для этого нам необходимо реализовать операцию вставки в очередь. `BFS` позволяет находить сразу самый короткий путь в графе, но занимает больше памяти.

```prolog
bfs(Start, End) :-
    get_time(Start_time),
    bfs_other([[Start]], End, Length), !,
    get_time(Finish_time), 
    Time is Finish_time - Start_time,
    write("Statitics: "), write("Time: "), write(Time), write("\tLength: "), write(Length), nl.
bfs_other([[End|T]], End, Length) :- 
    print_list([End|T], C),
    Length=C.
bfs_other([Now|CheckTail], End, Length) :-
    findall(Z, prolong(Now, Z), T),
    append(CheckTail, T, Next), !,
    bfs_other(Next, End, Length).
```

Поиск с помощью алгоритма с итерационным погружением позволяет постепенно углубяться в наш граф, находя таким образом кратчайший путь. Этот алгоритм берет лучшие стороны алгоритма `BFS` искючая повышенные требования к памяти, но его сложность ненамного выше.

```prolog
iddfs(Start, End) :-
    get_time(Start_time),
    integer_c(Level),
    depth_id([Start], End, Level, Length), !,
    get_time(Finish_time), 
    Time is Finish_time - Start_time,
    write("Statitics: "), write("Time: "), write(Time), write("\tLength: "), write(Length), nl.
depth_id([End|T], End, 0, Length) :- 
    print_list([End|T], C),
    Length=C.
depth_id(Path, End, N, Length) :-
    N > 0,
    prolong(Path, NextPath), 
    N1 is N - 1,
    depth_id(NextPath, End, N1, Length).
```

Для алгоритма `A-star` нам необходимо ввести вес перехода между состояниями и некую эвристику, которая будет показывать насколько близко мы приблизились к финальному состоянию. 

Вес перехода между состояниями равен 1, так как по сути наш вес отражает количество шагов сделанных при поиску в графе. Введем функцию эвристики на нашем графе, для этого будем текущее и конечное состояние. Будем считать число элементов стоящих не на своих местах, т.е чем меньше такое число, то тем ближе мы приблизились к решению.
```prolog
check_differ([],[],0).
check_differ([X|T],[Y|T1],C) :-
    X \= Y,
    check_differ(T, T1, C1),
    C is C1 + 1.
check_differ([X|T],[Y|T1],C) :-
    X = Y,
    check_differ(T, T1, C).

h(X, C, End) :- check_differ(X, End, C).

weight(C:[X|_], C1, End) :- h(X, H, End), C1 is C + H.
```

C помощью предиката `check_differ` мы будем вычислять количество мячей находящихся не на своих местах. `h` нужен для возврата этого значения в предикат `weight`, который будет складывать значение эвристики и стоимости перехода.

Сама реализация алгоритма:

```prolog
a*(Start, End) :-
    get_time(Start_time),
    a_search([0:[Start]], End, Length), !,
    get_time(Finish_time), 
    Time is Finish_time - Start_time,
    write("Statitics: "), write("Time: "), write(Time), write("\tLength: "), write(Length), nl.
a_search([_:[End|T]], End, Length) :-
    print_list([End|T], N),
    Length=N.
a_search([Now|Queue], End, Length) :-
    findall(Next, prolong_a(Now, Next), Ways),
    insertall(Ways, Queue, NewQueue, End),
    a_search(NewQueue, End, Length).

insert(I, [P|T], [I, P|T], End) :-
    weight(I, C, End), weight(P, C1, End), C=<C1, !.
insert(I, [P|T], [P|R], End) :- 
    insert(I, T, R, End).
insert(P,[],[P], _).

insertall([], Queue, Queue, _).
insertall([P|T], Queue, ResQueue, End) :-
    insert(P, Queue, NewQueue, End),
    insertall(T, NewQueue, ResQueue, End).
```

## Результаты

> Приведите результаты работы программы: найденные пути, время, затраченное на поиск тем или иным алгоритмом, длину найденного первым пути. Используйте таблицы,
если необходимо.

| Алгоритм поиска | Длина найденного первым пути    | Время работы                      |
|-----------------|----------------------------------|-----------------------------------|
| В глубину       |                 16               |        0.002959966659545898       |
| В ширину        |                 16               |        0.007873058319091797        |
| ID              |                 16               |        0.008593082427978516        |
| A-star          |                 16               |         0.006783008575439453        |

```prolog
?- solve([w,w,w,0,b,b,b],[b,b,b,0,w,w,w]).
DFS START:
[w,w,w,0,b,b,b]
[w,w,w,b,0,b,b]
[w,w,0,b,w,b,b]
[w,0,w,b,w,b,b]
[w,b,w,0,w,b,b]
[w,b,w,b,w,0,b]
[w,b,w,b,w,b,0]
[w,b,w,b,0,b,w]
[w,b,0,b,w,b,w]
[0,b,w,b,w,b,w]
[b,0,w,b,w,b,w]
[b,b,w,0,w,b,w]
[b,b,w,b,w,0,w]
[b,b,w,b,0,w,w]
[b,b,0,b,w,w,w]
[b,b,b,0,w,w,w]
Statitics: Time: 0.0029599666595458984  Length: 16
DFS END

"BFS START:"
[w,w,w,0,b,b,b]
[w,w,0,w,b,b,b]
[w,w,b,w,0,b,b]
[w,w,b,w,b,0,b]
[w,w,b,0,b,w,b]
[w,0,b,w,b,w,b]
[0,w,b,w,b,w,b]
[b,w,0,w,b,w,b]
[b,w,b,w,0,w,b]
[b,w,b,w,b,w,0]
[b,w,b,w,b,0,w]
[b,w,b,0,b,w,w]
[b,0,b,w,b,w,w]
[b,b,0,w,b,w,w]
[b,b,b,w,0,w,w]
[b,b,b,0,w,w,w]
Statitics: Time: 0.007873058319091797   Length: 16
BFS END

IDDFS, START:
[w,w,w,0,b,b,b]
[w,w,w,b,0,b,b]
[w,w,0,b,w,b,b]
[w,0,w,b,w,b,b]
[w,b,w,0,w,b,b]
[w,b,w,b,w,0,b]
[w,b,w,b,w,b,0]
[w,b,w,b,0,b,w]
[w,b,0,b,w,b,w]
[0,b,w,b,w,b,w]
[b,0,w,b,w,b,w]
[b,b,w,0,w,b,w]
[b,b,w,b,w,0,w]
[b,b,w,b,0,w,w]
[b,b,0,b,w,w,w]
[b,b,b,0,w,w,w]
Statitics: Time: 0.008593082427978516   Length: 16
IDDFS, END

A-STAR, START:
[w,w,w,0,b,b,b]
[w,w,w,b,0,b,b]
[w,w,0,b,w,b,b]
[w,0,w,b,w,b,b]
[w,b,w,0,w,b,b]
[w,b,w,b,w,0,b]
[w,b,w,b,w,b,0]
[w,b,w,b,0,b,w]
[w,b,0,b,w,b,w]
[0,b,w,b,w,b,w]
[b,0,w,b,w,b,w]
[b,b,w,0,w,b,w]
[b,b,w,b,w,0,w]
[b,b,w,b,0,w,w]
[b,b,0,b,w,w,w]
[b,b,b,0,w,w,w]
Statitics: Time: 0.006783008575439453   Length: 16
A-STAR, END
true.
```

Оценивая полученные результаты, можно сказать, что самыми быстрыми алгоритмами оказались `DFS` и `A*`, что скорее всего связано с переходами между состояниями, так как они оптимальны и приводят к тому, что белые всегда стремятся влево, а чёрные вправо, что и позволяет `DFS` сразу же находить кратчайший маршрут.

`A*` всегда находит маршрут наимешьней стоимости, но стоимость маршрута в нашем случае является длиной пути, что и позволяет нам быстро найти кратчайший путь.

## Выводы

Благодаря данной лабораторной работе я освежил память по основным алгоритмам поиска в графе: `DFS` и `BFS`, а также познакомился с алгоритмом итеративного погружения и `A*`.

Алгоритм `DFS` хорошо показал себя в данной задаче, что не удивительно, учитывая выбранную реализацию перехода между состояниями.

Алгоритм `BFS` чаще всего позволяет быстро найти крайтчайший путь в графе, но из-за большего числа переходов между состояниями(как и алгоритм итеративного погружения) и возросшим требованиям к памяти оказался не самым эффективным.

Алгоритм `A-star` лучше всего использовать, когда необходимо отсечь большое количество вариантов, чтобы сразу находить кратчайший путь в графе. Алгоритм хорошо себя зарекомендовал (возмонжно из выбранной эвристики) и, скорее всего, хорошо себя покажет на более сложных условиях задачи.

Можно сделать вывод, что самым оптимальным алгоритмом в данной задаче является алгоритм `A-star`.

В данной лабораторной работе я смог реализовать основные алгоритмы поиска в пространстве состояний, оценить их практичность. Каждый алгоритм применим в различных условиях. Также я еще больше углубился в язык Пролог и восхитился тем, что с помощью его можно не сложно описать такие алгоритмы, как `A-star`, что потребовало бы больших сил, например, на языке `C++`

