# Реферат

## по курсу "Логическое программирование"

### студент: Белоносов К.А.

## Как использовать логические языки чтобы научить компьютер играть в шахматы/шашки

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

### Логические языки программирования

Прежде чем углубиться в тему реферата рассмотрим понятие логических языков программирования. Парадигма логического программирования – парадигма в основе которой лежит логика предикатов первого порядка. Для решения задачи мы записываем набор фактов и правил вывода, переносим их на логику предикатов и получаем решение с помощью логического интерпретатора. Наличие мощного инструментария, такого как механизм отката назад (бэктрекинг), унификация и работа с деревьями позволяет использовать логические языки программирования в сложных задачах связанных с искусственным интеллектом, например обработка естественного языка (NLP), реализация машинной математики и т.д. Хочется также отметить удобство использования логических языков программирования в системах контроля версий, в частности язык Prolog используется в Gerrit для написания правил изменения и слияния кода.
Первым логическим языком программирования является Planner. Хотя язык так и не был полностью реализован, он определил основное направление развития логических языков программирования, такие как механизм бэктрекинга и механизмы вывода. Наиболее известным логическим языком программирования является Prolog (Programming in logic), реализовавшим идеи использования логики в основе программирования. Идеи заложенные в языке Prolog оказали большое влияние на развитие искусственного интеллекта. В дальнейшем были разработаны и другие языки программирования, такие как Datalog, Oz, Mercury (который был призван улучшить производительность пролога).

### Язык Prolog

В основе языка Prolog лежит язык предикатов логики дизъюнктов Хорна, являющаяся подмножеством логики предикатов первого порядка. Нельзя также не отметить тот факт, что Prolog является полным по Тьюрингу. Также Prolog имеет динамическую типизацию и декларативную семантику, заключающуюся в написании программы в виде фактов и правил вывода. Наши являются предикатами, состоящими из более мелких атомов. Далее с помощью предикатов записываются правила вывода. Совокупность фактов и правил вывода называется базой знаний, тогда работа нашей программы сводится к запросам к этой базе знаний. Процесс поиска решения логическим интерпретатором по сути является поиском в глубину, при котором наш запрос сопоставляется с ранее записанными нами фактами, происходит процесс унификации. Сам процесс построения программы напоминает записи на языке логики предикатов, где «,» тождественен конъюнкции, наличие нескольких фактов для одного предиката это дизъюнкция (хотя её можно записать в более явном виде с помощью знака «;»). Знак «:-» является аналогом импликации. Существует также предикат not() выполняющий функцию отрицания, но назвать его настоящим отрицанием мы не можем, ввиду того, что отрицание нарушает форму дизъюнкта Хорна, поэтому not() определяет отрицание по неуспеху. Также мы можем управлять нашим перебором и поиском решения с помощью оператора «!» (А также выполнять некоторые фокусы, не совсем корректные в рамках логического программирования, например ввести конструкцию if else).
Язык Prolog обладает большим потенциалом, для выполнения различного рода задач. Он хорошо себя показывает для представление реляционной модели данных, благодаря чему мы можем получать необходимые нам сведения с помощью запросов на языке логики. В тоже время Prolog хорошо справляется с деревьями (Ведь они лежат в его основе), что позволяет решать такие задачи, как:

1. Обработка естественных и искусственных языков
2. Поиск решения в графе состояния (Искусственный интеллект)
3. Системы проверки доказательств
4. Поиск с эвристикой

Поговорим отдельно о поиске с эвристикой, в частности об играх. Эвристика часто используется в играх, например в шахматах, о которых я расскажу в следующем разделе.

## Шахматы

### Правила игры

Шахматы – настольная логическая игра, рассчитанная на 2 двух человек, проводимая на 64-клетчатой доске, сочетающая в себе элементы искусства, науки и спорта.
Окончательные правила шахмат сформировались к XV веку.
Состав фигур:

1. 8 пешек
2. 2 ладьи
3. 2 коня
4. 2 слона
5. ферзь
6. король

Большинство знает как ходят большинство фигур, поэтому не буду уделять этому внимание, но стоит заметить что существует 2 особых хода, которые необходимо учитывать в шахматных алгоритмах:

1. Взятие на проходе: Возможность съесть пешку противника, которая совершила 1 ход на 2 клетки и встала рядом с пешкой оппонента.

2. Рокировка: Возможность поменять 1 раз за матч переместить короля на 2 клетки к ладье и ладью поставить за короля. Выполняется если между королем и ладьёй нет фигур и они не совершили ни одного хода за матч.

### История развития шахматных программ

Первыми попытками создать программу, способную играть в шахматы предпринял Алан Тьюринг в 1951, написав только алгоритм и выполняя его, был своего рода машиной. В это же время Клод Шеннон написал статью о 2 стратегиях поиска лучшего хода.

1. Перебор всех возможных ходов, на определенную глубину
2. Выборочное погружение, основанное на уже накопленном шахматном опыте.

Первые варианты программ стали появляться еще в 50х годах, но они не были столь эффективны плюс работали на не полной доске, но в 1962 году был открыт алгоритм alpha-beta существенно сокративший перебор. В дальнейшем произошло аппаратное наращивание мощностей, к чему приложил руку небезызвестный Кен Томпсон и лаборатория Bell. Они использовали отдельные шахматные чипы. Вскоре после этого группа аспирантов создала шахматный компьютер chip test, что в последствии, при поддержке IBM, переросло в создание компьютера DeepBlue, известного своей победой над Гариком Каспаровым. Происходило дальнейшее увеличение мощностей компьютеров, также находились интересные эвристики, в частности NullMove.

Большой прорыв в этом направлении произошел относительно недавно, когда нейронная сеть alpha-zero, смогла обыграть традиционный шахматный драйвер stockfish. При этому alpha-zero продумывала ходы не так глубоко, как stockfish, да и в тоже время требовала намного меньше ресурсов.
Основные алгоритмы
Важнейшим из алгоритмов оптимизации перебора является алгоритм alpha-beta. Стратегия алгоритма заключается в том, что если мы совершим свой ход, а противник свой, то следующий наш ход ставящий нас в положение хуже, чем лучший ход противника нам не следует рассматривать. Такое правило работает для каждого уровня погружения. Поэтому мы можем хранить 2 значения: alpha – лучшее значение с предыдущего уровня(Наш ход)и beta – лучшее значение с пред предыдущего уровня. Полученными нами результат работы всегда будет лежать на отрезке [alpha;beta].  
Другим немало важным алгоритмом является алгоритм NegaScout, который использовался в известной машине Deep Blue. Он является некой оптимизацией алгоритма alpha-beta. Идея алгоритма следующая, прежде чем смотреть рассматривать узел, следует отсечь за перебором с нулевым окном – alpha, alpha + 1. Если результат улучшает alpha, продолжаем перебор, иначе запускаем перебор от полученного значения до beta. В случае если полученное значение равно beta, то мы сразу можем вернуть beta. Этот алгоритм показывает себя очень хорошо и дает ускорение до 50%.

### Реализация шахмат на прологе

Для реализации шахмат на прологе нам нужно сначала рассмотреть 2 вещи: представление состояния игрового поля и способы перехода между состояниями. Игровое поле можно представить списком фигур находящихся на доске, с указанием их позиции. Это очень удобное представление, так как мы уже знаем, что список является родной структурой данных для пролога. Переходы между состояниями можем реализовать с помощью уже знакомого нам move.

Опишем также предикат для начала игры. Необходимо также сделать проверку «хорошего хода» - ход должен совершаться при условии того, что фигура не попадет под мат, а также, что на этой клетке находится другая фигура и принцип работы с этой фигуры (Съесть, рокировка, взятие на проходе).

Далее необходимо написать саму логику игры, выбор цвета фигур, смена сторон при ходе, событие проигрыша одного из участников. Также необходимо предусмотреть ничью. Определимся с ходами компьютера, можно сделать 2 подхода: использовать сложные алгоритмы эвристики, в том числе alpha-beta отсечение или положиться на простые алгоритмы, например на ход, при котором будет съедена фигура самой высокой важности. Да такую программу легко можно обыграть, но для начального проекта будет в самый раз.

## Заключение

В данной работе я познакомился с историей развития шахматных движков, основных шахматных алгоритмов и влияние на развитие компьютерной техники. Работа оказалось очень интересной, ведь шахматы столь давно существующая игра, до сих пор не была полностью изучена. Также при изучении материала меня поразило влияние шахмат, какой немыслимый фурор произвела победа DeepBlue над Каспаров. После этой работы хочется еще раз окунуться в мир этой удивительной игры. Также я привел описание простейшей шахматной программы на прологе. Конечно, написать подобную программу будет несколько тяжелее на логических языках программирования, но это интересная задачка покажет всю мощность пролога в решении задач поиска.

## Список литературы

1. Корнилов Е.Н. - "Программирование шахмат и других логических игр"
2. Сошников Д.В. - "Парадигма логического программирования"
3. Клоксин У. Мелиш К. - "Программирование на языке Пролог"
4. Братко И. - "Программирование на языке Пролог для алгоритмов искуственного интеллекта"
5. Интернет ресурс - "Википедия"