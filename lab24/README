Сборка программы: make      
Удаление мусора:  make clean
Запуск программы: ./lab24   

Построение дерева выражений.
    Общий алгоритм:
        Ищется главный оператор, относительно которого выражение разбивается на две
        части, рекурсивно вычисляемые этим же алгоритмом, и образующие левое и правое
        поддеревья.
        Главный оператор помещается в вершину дерева, а то, что по бокам -- в поддеревья.

    Поиск главного (образующего вершину) оператора:
        Ищется последний оператор с наименьшим приоритетом. Если это степень, то из-за
        её правоассоциативности идём влево до самой первой степени в цепочке связанных
        степеней (вторая ^ в 1^2 + 2^3^4), которую и считаем главным оператором.

    Пример:
        [2, +, 2, *, 2]
        Последний оператор с наименьшим приоритетом -- '+'. Заносим его в вершину и
        разбиваем выражение относительно него на две части: [2] и [2, *, 2], каждое из
        которых вычисляем таким же образом. В первом first == last (0 == 0, это индекс
        в массиве), поэтому это - число.
        Получается дерево
        +
        __2
        __*
        ____2
        ____2

Задание варианта (упростить, возводя числа в целые степени (2^3 менять на 8, etc)).
    Находим (функция tree.c:match_power) дерево вида
    ^
        (int/float) число1
        (int) число2
    и заменяем (tree.c:transform_power) на дерево вида
    (int/float) число1^число2 (просто целое или машинно-рациональное число).
    Рекурсивно выполняя (tree.c:tree_transform) этот процесс для дерева снизу
    вверх, гарантированно получаем вычисление всех численных степеней.
    Это верно и для сложных выражений. К примеру, для 2^3^4 == 2^(3^4)
    сначала будет вычислено k = 3^4, а только потом 2^k. Именно ради этой
    "тразитивности" вычислений обход и производится обход ЛПК (лево-корень-право).
    При этом обходе первая замена оказывается самой левой и самой нижней.

